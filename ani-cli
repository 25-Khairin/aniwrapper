#!/usr/bin/env bash

CFG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/aniwrapper"
HISTORY_DB="$CFG_DIR/history.sqlite3"
ROFI_CFG="$CFG_DIR/themes/aniwrapper.rasi"
ROFI_THEME="aniwrapper.rasi"
THEMES="alter|aniwrapper|dracula|doomone|fancy|material|monokai|nord|nord2|onedark"
ANIWRAPPER_ICON_PATH="$CFG_DIR/icons/icon-64.png"
MAISAN_ICON_PATH="$CFG_DIR/icons/MYsan.png"
DPI=96
IS_ROFI=1
VERBOSE=0
SILENT=0
FIRST_EP_NUMBER=1
PLAYER_FN="mpv"

die() {
	((SILENT != 1)) && printf "\033[1;31m%s\033[0m\n" "$*" >&2
	exit 1
}

# display an error message to stderr (in red)
err() {
	((SILENT != 1)) && printf "\033[1;31m%s\033[0m\n" "$*" >&2
}

lg() {
	((VERBOSE == 1)) && printf "\033[1;35m%s\033[0m\n" "$*" >&2
}

# display an informational message (first argument in green, second in magenta)
inf() {
	printf "\033[1;32m%s \033[1;35m%s\033[0m\n" "$1" "$2"
}

# prompts the user with message in $1-2 ($1 in blue, $2 in magenta) and saves the input to the variables in $REPLY and $REPLY2
prompt() {
	printf "\033[1;34m%s\033[1;35m%s\033[1;34m: \033[0m" "$1" "$2"
}

# displays an even (cyan) line of a menu line with $2 as an indicator in [] and $1 as the option
menu_line_even() {
	printf "\033[1;34m[\033[1;36m%s\033[1;34m] \033[1;36m%s\033[0m\n" "$2" "$1"
}

# displays an odd (yellow) line of a menu line with $2 as an indicator in [] and $1 as the option
menu_line_odd() {
	printf "\033[1;34m[\033[1;33m%s\033[1;34m] \033[1;33m%s\033[0m\n" "$2" "$1"
}

menu_line_alternate() {
	menu_line_parity=${menu_line_parity:-0}

	if [ "$menu_line_parity" -eq 0 ]; then
		menu_line_odd "$1" "$2"
		menu_line_parity=1
	else
		menu_line_even "$1" "$2"
		menu_line_parity=0
	fi
}

# displays a warning (red) line of a menu line with $2 as an indicator in [] and $1 as the option
menu_line_strong() {
	printf "\033[1;34m[\033[1;31m%s\033[1;34m] \033[1;31m%s\033[0m\n" "$2" "$1"
}

check_input() {
	if [[ -z "$ep_choice_start" ]] && [[ -z "$ep_choice_end" ]]; then
		die "No episode(s) selected"
	fi
	[ "$ep_choice_start" -eq "$ep_choice_start" ] 2> /dev/null || die "Invalid number entered: $ep_choice_start"
	episodes=$ep_choice_start
	if [ -n "$ep_choice_end" ]; then
		[ "$ep_choice_end" -eq "$ep_choice_end" ] 2> /dev/null || die "Invalid number entered: $ep_choice_end"
		episodes=$(seq "$ep_choice_start" "$ep_choice_end")
	fi
}

# get the download page url
get_dpage_link() {
	anime_id=$1
	ep_no=$2

	# credits to fork: https://github.com/Dink4n/ani-cli for the fix
	for params in "-episode-$ep_no" "-$ep_no" "-episode-$ep_no-1" "-camrip-episode-$ep_no"; do
		anime_page=$(curl -s "$BASE_URL/$anime_id$params")
		printf '%s' "$anime_page" | grep -q '404' || break
	done

	printf '%s' "$anime_page" |
		sed -n -E 's/^[[:space:]]*<a href="#" rel="100" data-video="([^"]*)".*/\1/p' |
		sed 's/^/https:/g'
}

decrypt_link() {
	lg "BEGIN: decrypt_link()" > /dev/stderr
	ajax_url="https://gogoplay.io/encrypt-ajax.php"

	#get the id from the url
	video_id=$(echo "$1" | cut -d\? -f2 | cut -d\& -f1 | sed 's/id=//g')
	lg "video_id -> $video_id" > /dev/stderr

	#construct ajax parameters
	secret_key='3235373436353338353932393338333936373634363632383739383333323838'
	iv='34323036393133333738303038313335'
	ajax=$(echo "$video_id" | openssl enc -aes256 -K "$secret_key" -iv "$iv" -a)
	lg "ajax -> $ajax" > /dev/stderr

	#send the request to the ajax url
	curl -s -H 'x-requested-with:XMLHttpRequest' "$ajax_url" -d "id=$ajax" -d "time=69420691337800813569" |
		sed -e 's/\].*/\]/' -e 's/\\//g' |
		grep -Eo 'https:\/\/[-a-zA-Z0-9@:%._\+~#=][a-zA-Z0-9][-a-zA-Z0-9@:%_\+.~#?&\/\/=]*'
	lg "END: decrypt_link()" > /dev/stderr
}

get_video_quality() {
	dpage_url=$1
	video_links=$(decrypt_link "$dpage_url")
	case $quality in
		best)
			video_link=$(printf '%s' "$video_links" | head -n 4 | tail -n 1)
			;;

		worst)
			video_link=$(printf '%s' "$video_links" | head -n 1)
			;;

		*)
			video_link=$(printf '%s' "$video_links" | grep -i "${quality}" | head -n 1)
			if [ -z "$video_link" ]; then
				err "Current video quality is not available (defaulting to best quality)"
				quality=best
				video_link=$(printf '%s' "$video_links" | head -n 4 | tail -n 1)
			fi
			;;
	esac
	printf '%s' "$video_link"
}

dep_ch() {
	for dep; do
		if ! command -v "$dep" > /dev/null; then
			die "Program \"$dep\" not found. Please install it."
		fi
	done
}

notification() {
	((SILENT == 1)) && return 0
	msg="$*"
	if command -v "notify-send" > /dev/null; then
		notify-send -i "$ANIWRAPPER_ICON_PATH" "$msg"
	else
		inf "$msg"
	fi
}

generate_span() {
	msg="$*"
	span="<span foreground='#ecbe7b' style='italic' size='small'>$msg</span>"
	printf "%s\n" "$span"
}

#####################
##  Database Code  ##
#####################

run_stmt() {
	printf "%s\n" "$1" | sqlite3 -noheader -list "$HISTORY_DB"
}

# Return number of matches for anime/episode in db
check_db() {
	case "$1" in
		directory)
			stmt="SELECT COUNT(*) FROM file_history WHERE directory = '$2';"
			;;
		file)
			stmt="SELECT COUNT(*) FROM file_history WHERE directory = '$2' AND filename = '$3';"
			;;
		search)
			stmt="SELECT COUNT(*) FROM search_history WHERE anime_name = '$2';"
			;;
		watch | sync)
			stmt="SELECT COUNT(*) FROM watch_history WHERE anime_name = '$2' AND episode_number = '$3';"
			;;
		anime)
			stmt="SELECT COUNT(*) FROM anime WHERE anime_name = '$2';"
			;;
	esac
	res=$(run_stmt "$stmt")
	return "$res"
}

# return true (0) if $source_dt > $target_dt
check_date() {
	source_dt="$1"
	target_dt="$2"
	if [[ "$source_dt" < "$target_dt" ]] || [[ "$source_dt" == "$target_dt" ]]; then
		return 1
	else
		return 0
	fi
}

# updates search/watch date for passed in anime
update_date() {
	datetime=$(date +'%Y-%m-%d %H:%M:%S')
	stmt=""
	case "$1" in
		directory)
			stmt="UPDATE file_history SET watch_date = '$datetime' WHERE directory = '$2' and filename = 'DIRECTORY';"
			;;
		file)
			stmt="UPDATE file_history SET watch_date = '$datetime' WHERE directory = '$2' and filename = '$3';"
			;;
		search)
			stmt="UPDATE search_history SET search_date = '$datetime' WHERE anime_name = '$2';"
			;;
		sync)
			temp_dt="${3// /:}"
			[ -z "$temp_dt" ] && return 1
			hist_dt=$(run_stmt "SELECT watch_date FROM watch_history WHERE anime_name='$2' AND episode_number='$3';")
			hist_dt="${hist_dt// /:}"
			if ! check_date "$hist_dt" "$temp_dt"; then
				lg "Passed in date is older or same than current date... doing nothing"
				return 1
			fi
			stmt="UPDATE watch_history SET watch_date = '$temp_dt' WHERE anime_name = '$2' AND episode_number = $3;"
			;;
		watch)
			stmt="UPDATE watch_history SET watch_date = '$datetime' WHERE anime_name = '$2' AND episode_number = $3;"
			;;
		anime)
			return
			;;
	esac
	lg "UPDATE STMT -> $stmt"
	run_stmt "$stmt"
}

# inserts into search/watch history db
# check the anime_name/id
insert_history() {
	datetime=$(date +'%Y-%m-%d %H:%M:%S')
	lg "Checking if ($*) exists in db"
	if ! check_db "$@"; then
		lg "Match found... Updating row in history db..."
		update_date "$@"
		res=$?
	else
		lg "Row not found in DB... inserting"
		case "$1" in
			directory)
				stmt="INSERT INTO file_history(directory, filename, watch_date) VALUES('$2', 'DIRECTORY', '$datetime');"
				;;
			file)
				stmt="INSERT INTO file_history(directory, filename, watch_date) VALUES('$2', '$3', '$datetime');"
				;;
			search)
				stmt="INSERT INTO search_history(anime_name, search_date) VALUES('$2', '$datetime');"
				;;
			watch)
				stmt="INSERT INTO watch_history(anime_name, episode_number, watch_date) VALUES('$2', '$3', '$datetime');"
				;;
			sync)
				stmt="INSERT INTO watch_history(anime_name, episode_number, watch_date) VALUES('$2', '$3', '$4');"
				;;
			anime)
				stmt="INSERT INTO anime(anime_name, start_episode, end_episode, data_date) VALUES('$2', $3, $4, '$datetime');"
				;;
		esac
		lg "INSERT STATEMENT -> $stmt"
		run_stmt "$stmt"
		res=$?
	fi
	return $res
}

sync_search_history() {
	cnt=0
	errs=0
	while read -r line; do
		anime_name=$(awk -F '|' '{print $2}' <<< "$line")
		if sqlite3 -noheader "$HISTORY_DB" "SELECT COUNT(*) FROM search_history WHERE anime_name = '$anime_name'"; then
			search_date=$(awk -F '|' '{print $3}' <<< "$line")
			if ! sqlite3 "$HISTORY_DB" "INSERT INTO search_history(anime_name, search_date) VALUES('$anime_name', '$search_date')"; then
				((++errs))
				continue
			fi
			((++cnt))
		fi
	done < <(sqlite3 -list -noheader "$temp_db" "SELECT * FROM search_history")
	lg "$cnt rows inserted into search_history table"
	lg "$errs errors on insert"
}

sync_watch_history() {
	cnt=0
	errs=0
	while read -r line; do
		anime_name="${line/ //}"
		while read -r ep; do
			episode_num=$(awk -F '|' '{print $1}' <<< "$ep")
			watch_date=$(awk -F '|' '{print $NF}' <<< "$ep")
			if ! insert_history "sync" "$anime_name" "$episode_num" "$watch_date"; then
				((++errs))
				continue
			fi
			((++cnt))
		done < <(sqlite3 -list -noheader "$temp_db" "SELECT episode_number, watch_date FROM watch_history WHERE anime_name = '$anime_name'")
	done < <(sqlite3 -list -noheader "$temp_db" "SELECT anime_name FROM watch_history")
	lg "$cnt rows inserted into watch_history table"
	lg "$errs rows skipped on insert"
}

#####################
### Play from file###
#####################

# opens the passed in file with $PLAYER_FN
play_file() {
	lg "Checking if file is playable"
	if [[ "$1" =~ (\.mp4|\.mkv|\.ts|\.webm)$ ]]; then
		filename="${1##*/}"
		directory="${1%/*}"
		insert_history "file" "$directory" "$filename"
		notification "Playing $1"
		case "$PLAYER_FN" in
			mpv)
				nohup "$PLAYER_FN" --force-media-title="aniwrapper: play-from-file - $1" "$1" > /dev/null 2>&1 &
				;;
			mplayer)
				nohup "$PLAYER_FN" -title "aniwrapper: play-from-file - $1" "$1" > /dev/null 2>&1 &
				;;
			*)
				nohup "$PLAYER_FN" "$1" > /dev/null 2>&1 &
				;;
		esac
		return $?
	else
		die "File: $1 is not playable... Quitting"
	fi
}

get_directory_data() {
	search_dir="$1"
	inputlist=""
	watched=""
	cnt=1
	[ "$search_dir" = "/" ] && cnt=0 # account for no ../ on /
	for directory in "$1"/*; do
		directory="${directory##*/}"
		[ ! -d "$search_dir/$directory" ] && continue
		[ -z "$inputlist" ] && inputlist="$directory" || inputlist="$inputlist|$directory"
		if ! check_db "directory" "$search_dir/$directory"; then
			lg "$search_dir/$directory opened before... adding $cnt to list" 1> /dev/stderr
			[ -z "$watched" ] && watched="$cnt" || watched="$watched, $cnt"
		fi
		((++cnt))
	done
	shopt -s nullglob   # set nullglob to avoid printing output if no files with extension exist
	shopt -s nocaseglob # case insensitive globbing
	for filename in "$search_dir"/*.{mp4,mkv,ts,mp3,webm}; do
		filename="${filename##*/}"
		[ -z "$inputlist" ] && inputlist="$filename" || inputlist="$inputlist|$filename"
		if ! check_db "file" "$search_dir" "$filename"; then
			lg "$filename watched before... adding $cnt to list" 1> /dev/stderr
			[ -z "$watched" ] && watched="$cnt" || watched="$watched, $cnt"
		fi
		((++cnt))
	done
	shopt -u nullglob
	shopt -u nocaseglob
	if [[ -n "$inputlist" && "$search_dir" != / ]]; then
		inputlist="../|$inputlist|Back|Quit"
	elif [[ -z "$inputlist" && "$search_dir" != / ]]; then
		inputlist="../|Back|Quit"
	elif [[ "$search_dir" = / ]]; then
		inputlist="$inputlist|Quit"
	else
		inputlist="Quit"
	fi
	lg "INPUT LIST: $inputlist" 1> /dev/stderr
	lg "WATCHED LIST: $watched" 1> /dev/stderr
}

# recursive function for finding path to video file given a starting directory
find_media() {
	inp="$1"
	[ -z "$inp" ] && die "No directory"
	lg "BEGIN find_media() on $inp" 1> /dev/stderr

	# base case hit when a file is found
	if [ -f "$inp" ]; then
		printf "%s\n" "$inp"
		return 0
	fi

	get_directory_data "$inp"
	selection="$(rofi -dpi "$DPI" -dmenu -no-custom -async-pre-read 33 -config "$ROFI_CFG" \
		-l 15 -i -sep '|' -mesg "$(generate_span "Current directory: $inp")" -a "$watched" \
		-p "Enter selection" -window-title 'aniwrapper' <<< "$inputlist")"
	[ -z "$selection" ] && return 1
	case "$selection" in
		Back | ../)
			dotdotslash="${inp%/*}"
			[ -z "$dotdotslash" ] && dotdotslash="/"
			insert_history "directory" "$dotdotslash"
			find_media "$dotdotslash"
			;;
		Quit)
			return 1
			;;
		*)
			if [ -d "$inp/$selection" ]; then
				insert_history "directory" "$inp/$selection"
				if [ "$inp" = "/" ]; then
					find_media "/$selection"
				else
					find_media "$inp/$selection"
				fi
			else
				find_media "$inp/$selection"
			fi
			;;
	esac
}

#####################
##   main code     ##
#####################

get_search_query() {
	if [ $# -gt 0 ]; then
		query="${*// /-}"
	elif [ "$IS_ROFI" -eq 1 ]; then
		stmt="SELECT id || '. ' || anime_name FROM search_history ORDER BY search_date DESC;"
		msg="Choose from list of searched anime below, or enter a unique name of an anime to search for"
		query=$(rofi -dpi "$DPI" -dmenu -l 15 -p "Search Anime:" \
			-mesg "$(generate_span "$msg")" \
			-config "$ROFI_CFG" -window-title 'aniwrapper' < <(run_stmt "$stmt"))
		query="${query//[1-9]*\. /}"
	elif [ "$IS_ROFI" -eq 0 ]; then
		prompt "Search Anime"
		read -r query
	fi
}

# get anime name along with its id
search_anime() {
	if [[ $# -gt 1 ]]; then
		# if multi-word query, concatenate into one string and replace spaces with '-'
		search="$*"
		search="${search// /-}"
	else
		# if one word, remove leading or trailing whitespace
		search="${1// /}"
	fi
	lg "Search Query: $search"
	curl -s "$BASE_URL//search.html" \
		-G \
		-d "keyword=$search" |
		sed -n -E '
		s_^[[:space:]]*<a href="/category/([^"]*)" title="([^"]*)".*_\1_p
		'
}

search_eps() {
	anime_id=$1
	result=$(get_dpage_link "$anime_id" 0)
	FIRST_EP_NUMBER="${result:-1}"
	LAST_EP_NUMBER=$(curl -s "$BASE_URL/category/$anime_id" |
		sed -n -E '
        /^[[:space:]]*<a href="#" class="active" ep_start/{
        s/.* '\''([0-9]*)'\'' ep_end = '\''([0-9]*)'\''.*/\2/p
        q
        }
    ')
	# lg "Anime $anime_id not in anime database... inserting into database" > /dev/stderr
	# insert_history "anime" "$anime_id" "$FIRST_EP_NUMBER" "$LAST_EP_NUMBER"
	FIRST_EP_NUMBER="${FIRST_EP_NUMBER%% }"
	LAST_EP_NUMBER="${LAST_EP_NUMBER%% }"
	lg "FIRST EP NUMBER: $FIRST_EP_NUMBER"
	lg "LAST EP NUMBER: $LAST_EP_NUMBER"
}

# Select anime from query results
anime_selection() {
	search_results=$*
	if ((IS_ROFI == 1)); then
		menu=""
		searched=""
		cnt=0
		while read -r anime_id; do
			[[ -z "$menu" ]] && menu="$((cnt + 1)). $anime_id" ||
				menu="$menu|$((cnt + 1)). $anime_id"
			if ! check_db "search" "$anime_id"; then
				[[ -z "$searched" ]] && searched="$cnt" || searched="$searched, $cnt"
			fi
			((++cnt))
		done <<< "$search_results"
		menu="$menu|$((++cnt)). Search another anime|$((++cnt)). Quit"

		# get the anime from indexed list
		msg="$(generate_span "Query: $query")"
		selection="$(rofi -dpi "$DPI" -dmenu -no-custom \
			-async-pre-read 33 -config "$ROFI_CFG" -l 15 -i -sep '|' \
			-mesg "$msg" -a "$searched" -p "Enter selection" -window-title 'aniwrapper' <<< "$menu")"
		choice="${selection%%.*}" # remmove everything from . to end
		lg "CHOICE: $choice"
		if ((choice == cnt)); then
			die "Quitting"
		elif ((choice == --cnt)); then
			stream
			return $?
		fi
	else
		count=1
		while read -r anime_id; do
			menu_line_alternate "$anime_id" "$count"
			: count=$((count += 1))
		done <<< "$search_results"
		prompt "Enter choice"
		read -r choice
	fi

	# Check if input is a number
	[[ "$choice" -eq "$choice" ]] 2> /dev/null || die "Invalid number entered"

	count=1
	while read -r anime_id; do
		if [[ "$count" -eq "$choice" ]]; then
			selection_id=$anime_id
			break
		fi
		count=$((count + 1))
	done <<< "$search_results"

	[[ -z "$selection_id" ]] && die "Invalid number entered"
	insert_history "search" "$selection_id" &
	lg "Selection: $selection_id"
	search_eps "$anime_id"
	return 0
}

episode_selection() {
	ep_choice_start=1
	if ((IS_ROFI == 1)); then
		lg "Anime ID: $anime_id"
		stmt="SELECT episode_number FROM watch_history WHERE anime_name = '$anime_id';"

		# Get Watch History for $anime_id as comma separated list
		watch_history=""
		while read -r i; do
			[[ -z "$watch_history" ]] && watch_history="$((--i))" || watch_history="$watch_history, $((--i))"
		done < <(run_stmt "$stmt")
		lg "Episode watch history -> $watch_history"

		# get user choice and set the start and end
		msg1="Anime Name: $anime_id"
		msg2="Range of episodes can be provided as: START_EPISODE - END_EPISODE"
		[[ "$is_download" -eq 1 ]] && msg=$(printf "%s\n%s" "$(generate_span "$msg1")" "$(generate_span "$msg2")") || msg=$(printf "%s\n" "$(generate_span "$msg1")")
		choice=$(
			seq "$FIRST_EP_NUMBER" "$LAST_EP_NUMBER" |
				rofi -dpi "$DPI" -dmenu -l 12 \
					-theme-str 'window {width: 45%;}' \
					-a "$watch_history" \
					-p "Select Episode [$FIRST_EP_NUMBER, $LAST_EP_NUMBER]:" \
					-mesg "$msg" -window-title 'aniwrapper' \
					-config "$ROFI_CFG"
		)
		ep_choice_start=$(printf '%s\n' "${choice}" | awk '{print $1}')
		ep_choice_end=$(printf '%s\n' "${choice}" | awk '{print $NF}')
		lg "START: $ep_choice_start | END: $ep_choice_end"
	elif ((LAST_EP_NUMBER > 1)); then
		[[ "$is_download" -eq 1 ]] &&
			inf "Range of episodes can be specified: start_number end_number"
		prompt "Choose episode" "[$FIRST_EP_NUMBER-$LAST_EP_NUMBER]"
		read -r ep_choice_start ep_choice_end
		[[ -z "$ep_choice_end" ]] && ep_choice_end="$ep_choice_start"
	fi
	if [[ "$(echo "$ep_choice_start" | awk '{ printf substr($0, 1, 1) }')" = "h" ]]; then
		lg "IS A HALF EPISODE"
		half_ep=1
		ep_choice_start=$(echo "$ep_choice_start" | awk '{ printf substr($0, 2) }')
		ep_choice_end=$ep_choice_start
	fi
	if (((ep_choice_start <= 0 || ep_choice_start > LAST_EP_NUMBER) || ep_choice_end < ep_choice_start || ep_choice_end > LAST_EP_NUMBER)); then
		die "Invalid episode/range entered: ep_start -> $ep_choice_start | ep_end -> $ep_choice_end"
	fi
	# if only one episode was entered, set ep_choice_end to empty string so only selected episode plays
	# otherwise plays from ep 1 - ep_choice_start
	((ep_choice_start == ep_choice_end)) && ep_choice_end=""
}

open_episode() {
	anime_id=$1
	episode=$2
	ddir="$3"

	if [ $half_ep -eq 1 ]; then
		temp_ep=$episode
		episode=$episode"-5"
	fi

	# Don't update watch history if downloading episode
	insert_history "watch" "$anime_id" "$episode"

	lg "Getting data for episode $episode"
	dpage_link=$(get_dpage_link "$anime_id" "$episode")
	video_url=$(get_video_quality "$dpage_link")
	if [ -z "$video_url" ]; then
		die "Video URL not found"
	fi
	lg "Download link: $dpage_link"
	lg "Video url: $video_url"

	if [ $half_ep -eq 1 ]; then
		episode=$temp_ep
		half_ep=0
	fi

	if [ "$is_download" -eq 0 ]; then
		kill "$PID" > /dev/null 2>&1
		case "$PLAYER_FN" in
			mpv)
				nohup "$PLAYER_FN" --referrer="$dpage_link" "$video_url" --force-media-title="aniwrapper: $anime_id E$(printf "%03d" "$episode")" > /dev/null 2>&1 &
				;;
			mplayer)
				nohup "$PLAYER_FN" -referrer "$dpage_link" "$video_url" -title "aniwrapper: $anime_id E$(printf "%03d" "$episode")" > /dev/null 2>&1 &
				;;
			vlc)
				nohup "$PLAYER_FN" --play-and-exit --http-referrer="$dpage_link" "$video_url" > /dev/null 2>&1 &
				;;
			*)
				nohup "$PLAYER_FN" "$video_url" > /dev/null 2>&1 & # try to open with just the video url
				;;
		esac
		PID=$!
		if command -v "notify-send" > /dev/null; then
			((SILENT != 1)) && notify-send -i "$ANIWRAPPER_ICON_PATH" "Playing $anime_id - Episode $episode"
		else
			((SILENT != 1)) && inf "Playing $anime_id - Episode $episode"
		fi
	else
		lg "Downloading episode $episode ..."
		dl_dir="${ddir// /}/$anime_id"
		episode=$(printf "%03d" "$episode") # add 0 padding to the episode name
		{
			mkdir -p "$dl_dir" || die "Could not create directory"
			if command -v "notify-send" > /dev/null; then
				if aria2c -x 16 -s 16 --referer="$dpage_link" "$video_url" --dir="$dl_dir" -o "$episode.mp4" --download-result=hide; then
					((SILENT != 1)) && notify-send -i "$ANIWRAPPER_ICON_PATH" "Download complete for ${anime_id//-/ } - Episode: $episode"
				else
					((SILENT != 1)) && notify-send -i "$MAISAN_ICON_PATH" "Download failed for ${anime_id//-/ } - Episode: $episode. Please retry or check your internet connection"
				fi
			else
				if aria2c -x 16 -s 16 --referer="$dpage_link" "$video_url" --dir="$dl_dir" -o "$episode.mp4" --download-result=hide; then
					((SILENT != 1)) && inf "Download complete for" "${anime_id//-/ } - Episode $episode"
				else
					((SILENT != 1)) && inf "Download failed for" "${anime_id//-/ } - Episode $episode, please retry or check your internet connection"
				fi
			fi
		}
	fi
}

stream() {
	lg "Running stream()"
	if [ "$#" -eq 0 ]; then
		get_search_query
	else
		get_search_query "$*"
	fi
	anime_id="${query// /}"
	[ -z "$anime_id" ] && die "No anime selected or queried"
	searched=0
	lg "Checking if anime: $anime_id has been searched before..."
	if check_db "search" "$anime_id"; then
		lg "$anime_id has been searched before"
		search_results=$(search_anime $query) # want word splitting to account for both input cases
		[ -z "$search_results" ] && die "No search results found"
		lg "SEARCH RESULTS: $search_results"
		if ! anime_selection "$search_results"; then
			die "No anime selection found"
		fi
	else
		selection_id="$anime_id"
		insert_history "search" "$anime_id" &
		search_eps "$anime_id"
	fi
	episode_selection
}

parse_args() {
	scrape=query
	quality=best
	is_download=0
	download_dir="."
	half_ep=0
	while getopts 'd:Hsvq:cf:t:T:CQ:D:Sp:' OPT; do
		case "$OPT" in
			d)
				is_download=1
				download_dir="$OPTARG"
				lg "DOWNLOAD DIR: $download_dir"
				;;
			H)
				scrape=history
				;;
			s)
				scrape=sync
				;;
			v)
				VERBOSE=1
				;;
			q)
				quality="$OPTARG"
				lg "passed in quality: $quality"
				;;
			c)
				IS_ROFI=0
				;;
			f)
				scrape="file"
				play_dir="$OPTARG"
				[ "$play_dir" != "/" ] && play_dir="$(sed -E 's/\/$//' <<< "$play_dir")" # remove trailing slash... unless searching / for some reason
				;;
			t)
				theme="$OPTARG"
				case "$theme" in
					aniwrapper | default)
						ROFI_THEME=aniwrapper.rasi
						;;
					*)
						if [[ "$theme" =~ ($THEMES) ]]; then
							ROFI_THEME="aniwrapper-$theme.rasi"
						else
							die "Invalid theme: $theme.  Please choose from: $THEMES"
						fi
						;;
				esac
				lg "Setting theme for ani-cli -> $ROFI_THEME"
				ROFI_CFG="$CFG_DIR/themes/$ROFI_THEME"
				lg "ROFI_CFG: $ROFI_CFG"
				;;
			T)
				ROFI_CFG="$OPTARG"
				[ ! -f "$ROFI_CFG" ] && die "$ROFI_CFG does not exist"
				lg "CUSTOM ROFI_CFG: $ROFI_CFG"
				;;
			C)
				lg "Connecting to history database -> $CFG_DIR/history.sqlite3"
				sqlite3 "$CFG_DIR/history.sqlite3"
				exit $?
				;;
			Q)
				query="$OPTARG"
				lg "DATABASE QUERY: $query"
				sqlite3 -line "$CFG_DIR/history.sqlite3" "$query"
				exit $?
				;;
			D)
				DPI="$OPTARG"
				;;
			S)
				SILENT=1
				;;
			p)
				PLAYER_FN="$OPTARG"
				if ! command -v "$PLAYER_FN" > /dev/null; then
					die "ERROR: $PLAYER_FN does not exist"
				fi
				;;
			*)
				inf "Invalid option"
				exit 1
				;;
		esac
	done
}

########
# main #
########
main() {
	case $scrape in
		query)
			BASE_URL="$(curl -s -L -o /dev/null -w "%{url_effective}\n" https://gogoanime.fi)"
			stream "$@"
			;;
		history)
			BASE_URL="$(curl -s -L -o /dev/null -w "%{url_effective}\n" https://gogoanime.fi)"
			stmt="SELECT anime_name FROM search_history ORDER BY search_date DESC"
			search_results="$(run_stmt "$stmt")"
			[ -z "$search_results" ] && die "History is empty"
			if ! anime_selection "${search_results[@]}"; then
				die "No anime selected"
			fi
			lg "SELECTION: $selection_id"

			stmt="SELECT episode_number FROM watch_history WHERE anime_name = '$selection_id' ORDER BY watch_date DESC LIMIT 1;"
			ep_choice_start=$(run_stmt "$stmt")
			lg "Most recently watched episode: $ep_choice_start"
			;;
		sync)
			prompt "Enter username for remote user"
			read -r username
			prompt "Enter host for remote user"
			read -r host

			connection_str="$username@$host"
			prompt "Enter port to connect to remote host with or leave blank for default (22)"
			read -r port
			[ -z "$port" ] && PORT=22 || PORT="$port"

			prompt "Enter path to private key (leave blank if unsure or not needed)"
			read -r key_path

			lg "Syncing database with: $connection_str on port $PORT"
			temp_db="/tmp/aniwrapper_tmp_history.sqlite3"

			if [[ -z "$key_path" ]]; then
				if ! scp -P "$PORT" "$connection_str:$HISTORY_DB" "$temp_db"; then
					die "Error getting database file from remote host"
				fi
			else
				if ! scp -P "$PORT" -i "$key_path" "$connection_str:$HISTORY_DB" "$temp_db"; then
					die "Error getting database file from remote host"
				fi
			fi
			sync_search_history && sync_watch_history
			exit $?
			;;
		file)
			lg "STARTING DIR: $play_dir"
			[ ! -d "$play_dir" ] && die "$play_dir does not exist"
			insert_history "directory" "$play_dir"
			video_path="$(find_media "$play_dir")"
			retcode="$?"
			if [ "$retcode" -ne 0 ]; then
				die "QUITTING"
			elif [ -z "$video_path" ]; then
				die "Something went wrong getting path... path is empty"
			fi
			lg "VIDEO PATH: $video_path"
			play_file "$video_path"
			exit $?
			;;
	esac

	check_input

	for ep in $episodes; do
		open_episode "$selection_id" "$ep" "$download_dir"
	done

	if [[ "$is_download" -eq 1 ]]; then
		lg "Finished downloading episodes: $episodes for $selection_id... exiting"
		exit 0
	fi

	if ((SILENT != 1)); then
		episode=${ep_choice_end:-$ep_choice_start}
		choice=''
		while :; do
			inf "Currently playing $selection_id episode" "${episode// /}/$LAST_EP_NUMBER"
			if ((episode != LAST_EP_NUMBER)); then
				menu_line_alternate "next episode" "n"
			fi
			if ((episode != FIRST_EP_NUMBER)); then
				menu_line_alternate "previous episode" "p"
			fi
			if ((FIRST_EP_NUMBER != LAST_EP_NUMBER)); then
				menu_line_alternate "select episode" "s"
			fi
			menu_line_alternate "replay current episode" "r"
			menu_line_alternate "search for another anime" "a"
			menu_line_alternate "select quality (current: $quality)" "Q"
			menu_line_strong "exit" "q"
			prompt "Enter choice"
			read -r choice
			case $choice in
				n)
					episode=$((episode + 1))
					;;
				p)
					episode=$((episode - 1))
					;;

				s)
					episode_selection
					episode=$ep_choice_start
					;;

				r)
					episode=$((episode))
					;;
				a)
					stream
					episode=$ep_choice_start
					lg "NEW EPISODE: $selection_id - $episode"
					;;
				Q)
					if ((IS_ROFI == 1)); then
						qualities="1. best|2. 1080p|3. 720p|4. 480p|5. 360p|6. worst"
						while IFS='|' read -ra quals; do
							for q in "${quals[@]}"; do
								if [[ "$(awk '{ print $NF }' <<< "$q")" == "$quality" ]]; then
									cur_quality="$((${q:0:1} - 1))"
									break
								fi
							done
						done <<< "$qualities"
						choice=$(rofi -dmenu -dpi "$DPI" -config "$ROFI_CFG" \
							-theme-str 'listview {columns: 1;} window {width: 25%;}' \
							-i -l 6 -no-custom -sep '|' -a "$cur_quality" -mesg "$(generate_span "Current quality: $quality")" \
							-p "Choose quality:" -window-title 'aniwrapper' -selected-row "$cur_quality" <<< "$qualities")
						quality=$(awk '{ print $2 }' <<< "$choice")
					else
						qualities="best|1080p|720p|480p|360p|worst"
						prompt "Choose quality [$qualities]"
						read -r quality
						while [[ ! "$quality" =~ ($qualities) ]]; do
							lg "$quality not a valid quality"
							prompt "Choose quality [$qualities]"
							read -r quality
						done
					fi
					episode=$((episode))
					;;

				q)
					break
					;;

				*)
					die "invalid choice"
					;;
			esac
			open_episode "$selection_id" "$episode" "$download_dir"
		done
	fi
}

dep_ch "$PLAYER_FN" "curl" "sed" "grep" "sqlite3" "rofi" "git" "aria2c"
parse_args "$@"
shift $((OPTIND - 1))
main "$@"
