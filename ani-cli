#!/usr/bin/env bash

BASE_URL=$(curl -s -L -o /dev/null -w "%{url_effective}\n" https://gogoanime.cm)
CFG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/aniwrapper"
HISTORY_DB="$CFG_DIR/history.sqlite3"
PLAYER_CMD="mpv"
ROFI_CFG="$CFG_DIR/themes/aniwrapper.rasi"
ROFI_THEME="aniwrapper.rasi"
THEMES="aniwrapper (default)|dracula|doomone|fancy|flamingo|material|nord|onedark"
ANIWRAPPER_ICON_PATH="$CFG_DIR/icons/icon-64.png"
MAISAN_ICON_PATH="$CFG_DIR/icons/MYsan.png"
DPI=96
VERBOSE=0

player_fn="mpv"
playable="\.mp4|\.mkv|\.ts|\.mp3|\.webm"
playable_list="mp4,mkv,ts,mp3,webm"
prog="ani-cli"
c_red="\033[1;31m"
c_green="\033[1;32m"
c_yellow="\033[1;33m"
c_blue="\033[1;34m"
c_magenta="\033[1;35m"
c_cyan="\033[1;36m"
c_reset="\033[0m"

help_text() {
	while IFS= read -r line; do
		printf "%s\n" "$line"
	done <<- EOF
		USAGE: $prog <query>
		 -h  show this help text
		 -d  download episode
		 -H  continue where you left off
	EOF
}

die() {
	printf "$c_red%s$c_reset\n" "$*" >&2
	exit 1
}

err() {
	printf "$c_red%s$c_reset\n" "$*" >&2
}

logger() {
	# prints passed in args to stdout if $VERBOSE is set to 1
	[ "$VERBOSE" -eq 1 ] && printf "%s\n" "$*" >&2
}

check_input() {
	[ "$ep_choice_start" -eq "$ep_choice_start" ] 2> /dev/null || die "Invalid number entered: $ep_choice_start"
	episodes=$ep_choice_start
	if [ -n "$ep_choice_end" ]; then
		[ "$ep_choice_end" -eq "$ep_choice_end" ] 2> /dev/null || die "Invalid number entered: $ep_choice_end"
		# create list of episodes to download/watch
		episodes=$(seq $ep_choice_start $ep_choice_end)
	fi
}

get_dpage_link() {
	# get the download page url
	anime_id=$1
	ep_no=$2

	# credits to fork: https://github.com/Dink4n/ani-cli for the fix
	# dub prefix takes the value "-dub" when dub is needed else is empty
	anime_page=$(curl -s "$BASE_URL/$anime_id${dub_prefix}-$ep_no")

	if printf '%s' "$anime_page" | grep -q "404"; then
		anime_page=$(curl -s "$BASE_URL/$anime_id${dub_prefix}-episode-$ep_no")
	fi

	printf '%s' "$anime_page" |
		sed -n -E 's/^[[:space:]]*<a href="#" rel="100" data-video="([^"]*)".*/\1/p' |
		sed 's/^/https:/g'
}

decrypt_link() {
	logger "BEGIN: decrypt_link()" > /dev/stderr
	ajax_url="https://gogoplay.io/encrypt-ajax.php"

	#get the id from the url
	video_id=$(printf "$1" | cut -d\? -f2 | cut -d\& -f1 | sed 's/id=//g')
	logger "video_id -> $video_id" > /dev/stderr

	#construct ajax parameters
	secret_key='3235373436353338353932393338333936373634363632383739383333323838'
	iv='34323036393133333738303038313335'
	ajax=$(printf "$video_id" | openssl enc -aes256 -K "$secret_key" -iv "$iv" -a)
	logger "ajax -> $ajax" > /dev/stderr

	#send the request to the ajax url
	curl -s -H 'x-requested-with:XMLHttpRequest' "$ajax_url" -d "id=$ajax" -d "time=69420691337800813569" | jq -r '.source[].file'
	logger "END: decrypt_link()" > /dev/stderr
}

get_video_quality() {
	dpage_url=$1
	video_links=$(decrypt_link "$dpage_url")
	case $quality in
		best)
			video_link=$(printf '%s' "$video_links" | head -n 4 | tail -n 1)
			;;
		worst)
			video_link=$(printf '%s' "$video_links" | head -n 1)
			;;
		*)
			video_link=$(printf '%s' "$video_links" | grep -iE "${quality}" | head -n 1)
			if [ -z "$video_link" ]; then
				err "Current video quality is not available (defaulting to best quality)"
				quality=best
				video_link=$(printf '%s' "$video_links" | head -n 4 | tail -n 1)
			fi
			;;
	esac
	printf '%s' "$video_link"
}

dep_ch() {
	for dep; do
		if ! command -v "$dep" > /dev/null; then
			die "Program \"$dep\" not found. Please install it."
		fi
	done
}

notification() {
	msg="$*"
	if command -v "notify-send" > /dev/null; then
		notify-send -i "$ANIWRAPPER_ICON_PATH" "$msg"
	else
		logger "$msg"
	fi
}

generate_span() {
	msg="$*"
	span="<span foreground='#ecbe7b' style='italic' size='small'>$msg</span>"
	printf "%s\n" "$span"
}

#####################
##  Database Code  ##
#####################

run_stmt() {
	printf "%s\n" "$1" | sqlite3 -noheader "$HISTORY_DB"
}

# Return number of matches for anime/episode in db
check_db() {
	if [[ "$1" == "directory" ]]; then
		stmt="SELECT DISTINCT COUNT(*) \
        FROM file_history \
        WHERE directory = '$2';"
	elif [[ "$1" == "file" ]]; then
		stmt="SELECT DISTINCT COUNT(*) \
        FROM file_history \
        WHERE directory = '$2' \
        AND filename = '$3';"
	elif [[ "$2" == "search" ]]; then
		stmt="SELECT DISTINCT COUNT(*) \
			  FROM search_history \
			  WHERE anime_name = '$1';"
	else
		stmt="SELECT DISTINCT COUNT(*) \
			  FROM watch_history \
			  WHERE anime_name = '$1' \
			  AND episode_number = '$2';"
	fi
	res=$(run_stmt "$stmt")
	return $res
}

# return true (0) if $source_dt > $target_dt
check_date() {
	source_dt="$1"
	target_dt="$2"
	if [[ "$source_dt" < "$target_dt" ]] || [[ "$source_dt" == "$target_dt" ]]; then
		return 1
	else
		return 0
	fi
}

# updates search/watch date for passed in anime
update_date() {
	datetime=$(date +'%Y-%m-%d %H:%M:%S')
	stmt=""
	if [[ "$1" == "directory" ]]; then
		logger "UPDATING FILE_HISTORY: directory='$2', filename='DIRECTORY', search_date='$datetime'"
		stmt="UPDATE file_history SET watch_date = '$datetime' \
			WHERE directory = '$2' and filename = '$3';"
	elif [[ "$1" == "file" ]]; then
		logger "UPDATING FILE_HISTORY: directory='$2', filename='$3', search_date='$datetime'"
		stmt="UPDATE file_history SET watch_date = '$datetime' \
			WHERE directory = '$2' and filename = '$3';"
	elif [[ "$2" == "search" ]]; then
		logger "UPDATING SEARCH_HISTORY: anime_name='$1', search_date='$datetime'"
		stmt="UPDATE search_history SET search_date = '$datetime' \
			WHERE anime_name = '$1';"
	elif [[ $# -ge 3 ]]; then
		temp_dt="${3// /:}"
		[ -z "$temp_dt" ] && return 1
		hist_dt=$(run_stmt "SELECT watch_date FROM watch_history WHERE anime_name='$1' AND episode_number='$2';")
		hist_dt="${hist_dt// /:}"
		logger "Checking if update is needed..."
		if ! check_date "$hist_dt" "$temp_dt"; then
			logger "Passed in date is older or same than current date... doing nothing"
			return 1
		fi
		logger "UPDATING watch_history from sync. watch_date -> $temp_dt"
		stmt="UPDATE watch_history SET watch_date = '$temp_dt' \
			WHERE anime_name = '$1' \
			AND episode_number = $2;"
	else
		logger "UPDATING WATCH_HISTORY: anime_name='$1', episode_number='$2' search_date='$datetime'"
		stmt="UPDATE watch_history SET watch_date = '$datetime' \
			WHERE anime_name = '$1' \
			AND episode_number = $2;"
	fi
	wait # in case there's another insert/update still running in background?
	run_stmt "$stmt"
}

# inserts into search/watch history db
# check the anime_name/id
insert_history() {
	datetime=$(date +'%Y-%m-%d %H:%M:%S')
	logger "Checking if ($*) exists in db"
	check_db "$@"
	res="$?"
	if [[ $res -gt 0 ]]; then
		logger "Match found... Updating row in history db..."
		update_date "$@"
		res=$?
	else
		logger "Row not found in DB... inserting"
		if [[ "$1" == "directory" ]]; then
			stmt="INSERT INTO file_history(directory, filename, watch_date) \
                VALUES('$2', 'DIRECTORY', '$datetime');"
		elif [[ "$1" == "file" ]]; then
			stmt="INSERT INTO file_history(directory, filename, watch_date) \
        VALUES('$2', '$3', '$datetime');"
		elif [[ "$2" == "search" ]]; then
			stmt="INSERT INTO search_history(anime_name, search_date) \
				VALUES('$1', '$datetime');"
		else
			stmt="INSERT INTO \
				watch_history(anime_name, episode_number, watch_date) \
				VALUES('$1', '$2', '$datetime');"
		fi
		logger "INSERT STATEMENT -> $stmt"
		wait # in case there's another insert/update still running in background
		run_stmt "$stmt"
		res=$?
	fi
	return $res
}

sync_search_history() {
	cnt=0
	errs=0
	while read -r line; do
		anime_name=$(awk -F '|' '{print $2}' <<< "$line")
		res=$(sqlite3 -noheader "$HISTORY_DB" "SELECT COUNT(*) FROM search_history WHERE anime_name = '$anime_name'")
		if [[ "$res" -eq 0 ]]; then
			search_date=$(awk -F '|' '{print $3}' <<< "$line")
			if ! sqlite3 "$HISTORY_DB" "INSERT INTO search_history(anime_name, search_date) VALUES('$anime_name', '$search_date')"; then
				((++errs))
				continue
			fi
			((++cnt))
		fi
	done < <(sqlite3 -list -noheader "$temp_db" "SELECT DISTINCT * FROM search_history")
	logger "$cnt rows inserted into search_history table"
	logger "$errs errors on insert"
}

sync_watch_history() {
	cnt=0
	errs=0
	while read -r line; do
		anime_name="${line/ //}"
		# for each episode of $anime_name on the remote machine, check local
		while read -r ep; do
			episode_num=$(awk -F '|' '{print $1}' <<< "$ep")
			watch_date=$(awk -F '|' '{print $NF}' <<< "$ep")
			if ! insert_history "$anime_name" "$episode_num" "$watch_date"; then
				((++errs))
				continue
			fi
			((++cnt))
		done < <(sqlite3 -list -noheader "$temp_db" "SELECT episode_number, watch_date FROM watch_history WHERE anime_name = '$anime_name'")
	done < <(sqlite3 -list -noheader "$temp_db" "SELECT DISTINCT anime_name FROM watch_history")
	logger "$cnt rows inserted into watch_history table"
	logger "$errs rows skipped on insert"
}

#####################
### Play from file###
#####################

# opens the passed in file with $PLAYER_CMD
play_file() {
	logger "Checking if file is playable"
	if [[ "$1" =~ ($playable)$ ]]; then
		filename="${1##*/}"
		directory="${1%/*}"
		insert_history "file" "$directory" "$filename" &
		if [[ "$1" =~ .mp3 ]]; then
			logger ".mp3 file found... playing without video"
			notification "Playing $1"
			$PLAYER_CMD --no-video "$1"
		else
			notification "Playing $1"
			$PLAYER_CMD "$1" > /dev/null 2>&1 &
		fi
		return $?
	else
		die "File: $1 is not playable... Quitting"
	fi
}

get_directory_data() {
	search_dir="$1"
	inputlist=""
	watched=""
	cnt=1
	[ "$search_dir" = "/" ] && cnt=0 # account for no ../ on /
	for directory in "$1"/*; do
		directory="${directory##*/}"
		[ -z "$inputlist" ] && inputlist="$directory" || inputlist="$inputlist|$directory"
		if ! check_db "directory" "$search_dir/$directory"; then
			logger "$search_dir/$directory opened before... adding $cnt to list" 1> /dev/stderr
			[ -z "$watched" ] && watched="$cnt" || watched="$watched, $cnt"
		fi
		((++cnt))
	done
	shopt -s nullglob   # set nullglob to avoid printing output if no files with extension exist
	shopt -s nocaseglob # case insensitive globbing
	for filename in "$1"/*."{$playable_list}"; do
		[ -z "$inputlist" ] && inputlist="$filename" || inputlist="$inputlist|$filename"
		if ! check_db "file" "$search_dir" "$filename"; then
			logger "$filename watched before... adding $cnt to list" 1> /dev/stderr
			[ -z "$watched" ] && watched="$cnt" || watched="$watched, $cnt"
		fi
		((++cnt))
	done
	shopt -u nullglob
	shopt -u nocaseglob
	logger "INPUTLIST: $inputlist"
	if [[ -n "$inputlist" && "$search_dir" != / ]]; then
		inputlist="../|$inputlist|Back|Quit"
	elif [[ -z "$inputlist" && "$search_dir" != / ]]; then
		inputlist="../|Back|Quit"
	elif [[ "$search_dir" = / ]]; then
		inputlist="$inputlist|Back|Quit"
	fi
	logger "INPUT LIST: $inputlist" 1> /dev/stderr
	logger "WATCHED LIST: $watched" 1> /dev/stderr
}

# recursive function for finding path to video file given a starting directory
find_media() {
	inp="$1"
	[ -z "$inp" ] && die "No directory"
	# workaround to allow logging w/o affecting return output
	logger "INPUT DIR: $inp" 1> /dev/stderr

	# base case hit when a file is found
	if [ -f "$inp" ]; then
		printf "%s\n" "$inp"
		return 0
	fi

	get_directory_data "$inp"
	[ -z "$inp" ] && return 1
	selection="$(rofi -dpi "$DPI" -dmenu -only-match -async-pre-read 33 -config "$ROFI_CFG" \
		-l 15 -i -sep '|' -mesg "$(generate_span "Current directory: $inp")" -a "$watched" \
		-p "Enter selection" <<< "$inputlist")"

	case "$selection" in
		Back | ../)
			dotdotslash="${inp%/*}"
			if [ -z "$dotdotslash" ]; then
				find_media "/"
			else
				find_media "$dotdotslash"
			fi
			;;
		Quit)
			return 1
			;;
		*)
			if [ ! -d "$inp/$selection" ] && [ ! -f "$inp/$selection" ]; then
				return 1
			else
				insert_history "directory" "$inp/$selection" &
				if [ "$inp" = "/" ]; then
					find_media "/$selection"
				else
					find_media "$inp/$selection"
				fi
			fi
			;;
	esac
}

#####################
##   main code     ##
#####################

# get query
get_search_query() {
	# Get search history
	stmt="SELECT DISTINCT id || '. ' || anime_name \
		  FROM search_history \
		  ORDER BY id DESC;"

	msg="Choose from list of searched anime below, or enter a unique name of an anime to search for"
	span="$(generate_span "$msg")"
	if [ -z "$*" ] && [ "$is_rofi" -eq 1 ]; then
		query=$(rofi -dpi "$DPI" -dmenu -l 15 -p "Search Anime:" \
			-mesg "$span" \
			-config "$ROFI_CFG" < <(run_stmt "$stmt"))
		# Remove the id from the query
		query="${query//[1-9]*\. /}"
		logger "Query: $query"
	elif [ "$is_rofi" -eq 0 ]; then
		printf "Search Anime: "
		read -r query
	else
		query=$*
	fi
}

search_anime() {
	# get anime name along with its id
	logger "NUM ARGS: $#"
	if [[ $# -gt 1 ]]; then
		# if multi-word query, concatenate into one string and replace spaces with '-'
		search="$*"
		search="${search// /-}"
	else
		# if one word, remove leading or trailing whitespace
		search="${1// /}"
	fi
	logger "Search Query: $search"
	titlepattern='<a href="/category/'
	curl -s "$BASE_URL//search.html" \
		-G \
		-d "keyword=$search" |
		sed -n -E '
		s_^[[:space:]]*<a href="/category/([^"]*)" title="([^"]*)".*_\1_p
		'
}

search_eps() {
	# get available episodes for anime_id
	anime_id=$1

	curl -s "$BASE_URL/category/$anime_id" |
		sed -n -E '
		/^[[:space:]]*<a href="#" class="active" ep_start/{
		s/.* '\''([0-9]*)'\'' ep_end = '\''([0-9]*)'\''.*/\2/p
		q
		}
		'
}

anime_selection() {
	# Select anime from query results
	search_results=$*
	if [ "$is_rofi" -eq 1 ]; then
		count=1
		menu=()
		res=()
		while read -r anime_id; do
			menu+="$count. $anime_id\n"
			idx=$((count - 1))
			res["$idx"]="$anime_id"
			count=$((count + 1))
		done <<- EOF
			$search_results
		EOF
		menu+="$count. Quit"

		searched=""
		cnt=0
		# Get the comma separated list of indexes of anime that has been searched before
		for anime in "${res[@]}"; do
			logger "ANIME: $anime"
			check_db "$anime" "search"
			if [[ $? -gt 0 ]]; then
				logger "$anime HAS BEEN SEARCHED BEFORE"
				if [ -z "$searched" ]; then
					searched="$cnt"
				else
					searched="$searched, $cnt"
				fi
			fi
			((++cnt))
		done
		logger "SEARCHED: $searched"

		# get the anime from indexed list
		msg="$(generate_span "Query: $query")"
		user_input=$(printf "${menu[@]}" |
			rofi -dpi "$DPI" -dmenu -config "$ROFI_CFG" \
				-a "$searched" \
				-l 12 -i -p "Enter selection:" \
				-async-pre-read 33 \
				-mesg "$msg" -only-match)
		[ -z "$user_input" ] && return 1
		if [ $(awk '{ print $NF }' <<< "$user_input") = "Quit" ]; then
			logger "QUITTING"
			return 1
		fi

		choice=$(printf '%s\n' "$user_input" | awk '{print $1}')
		# Remove period after number
		choice="${choice::-1}"
		name=$(printf '%s\n' "$user_input" | awk '{print $NF}')
	else
		menu_format_string='[%d] %s\n'
		menu_format_string_c1="$c_blue[$c_cyan%d$c_blue] $c_reset%s\n"
		menu_format_string_c2="$c_blue[$c_cyan%d$c_blue] $c_yellow%s$c_reset\n"
		count=1
		while read anime_id; do
			# alternating colors for menu
			[ $((count % 2)) -eq 0 ] &&
				menu_format_string=$menu_format_string_c1 ||
				menu_format_string=$menu_format_string_c2

			printf "$menu_format_string" "$count" "$anime_id"
			count=$((count + 1))
		done <<< "$search_results"
		printf "$c_blue%s$c_green" "Enter number: "
		read choice
		printf "$c_reset"
		name="$anime_id"
	fi

	logger "CHOICE: $choice"

	if [ "$is_rofi" -eq 1 ]; then
		# check both choice and name are set
		if [[ ! "$choice" ]] || [[ ! "$name" ]]; then
			die "Invalid choice... committing seppuku"
		fi
	fi
	# Check if input is a number
	[ "$choice" -eq "$choice" ] 2> /dev/null || die "Invalid number entered"

	# Select respective anime_id
	count=1
	while read -r anime_id; do
		if [ "$count" -eq "$choice" ]; then
			selection_id=$anime_id
			break
		fi
		count=$((count + 1))
	done <<- EOF
		$search_results
	EOF

	[ -z "$name" ] && name="$anime_id"
	insert_history "$name" "search" &

	printf "$c_reset"

	[ -z "$selection_id" ] && die "Invalid number entered"

	read -r last_ep_number <<- EOF
		$(search_eps "$selection_id")
	EOF
}

episode_selection() {
	ep_choice_start="1"
	if [ "$is_rofi" -eq 1 ]; then
		# select episode number for anime
		logger "Anime ID: $anime_id"
		stmt="SELECT DISTINCT episode_number \
        FROM watch_history \
        WHERE anime_name = '$anime_id';"
		hist=$(run_stmt "$stmt")
		# logger "HISTORY: ${hist[*]}"

		# Get Watch History for $anime_id as comma separated list
		watch_history=""
		for i in $hist; do
			if [[ "$watch_history" == "" ]]; then
				watch_history="$((--i))"
			else
				watch_history="$watch_history, $((--i))"
			fi
		done

		# get user choice and set the start and end
		msg=$(printf "%s\n%s" "$(generate_span "Anime Name: $anime_id")" "$(generate_span "Range of episodes can be provided as: START_EPISODE - END_EPISODE")")
		choice=$(
			seq 1 "$last_ep_number" |
				rofi -dpi "$DPI" -dmenu -l 12 \
					-a "$watch_history" \
					-p "Select Episode [1, $last_ep_number]:" \
					-mesg "$msg" \
					-config "$ROFI_CFG"
		)
		ep_choice_start=$(printf '%s\n' "${choice}" | awk '{print $1}')
		ep_choice_end=$(printf '%s\n' "${choice}" | awk '{print $NF}')
		logger "START: $ep_choice_start | END: $ep_choice_end"
	elif [ $last_ep_number -gt 1 ]; then
		[ $is_download -eq 1 ] &&
			printf "Range of episodes can be specified: start_number end_number\n"

		printf "${c_blue}Choose episode $c_cyan[1-%d]$c_reset:$c_green " $last_ep_number
		read ep_choice_start ep_choice_end
		printf "$c_reset"
	fi
	# check for half episode
	if [ "$(echo "$ep_choice_start" | awk '{ printf substr($0, 1, 1) }')" = "h" ]; then
		logger "IS A HALF EPISODE"
		half_ep=1
		ep_choice_start=$(echo "$ep_choice_start" | awk '{ printf substr($0, 2) }')
		ep_choice_end=$ep_choice_start
	fi
	if [[ -z "$ep_choice_start" ]] && [[ -z "$ep_choice_end" ]]; then
		die "No episode range entered"
	fi
	# if only one episode was entered, set ep_choice_end to empty string so only selected episode plays
	# otherwise plays from ep 1 - ep_choice_start
	if [[ "$ep_choice_start" -eq "$ep_choice_end" ]]; then
		ep_choice_end=""
	fi
	printf "$c_reset"

}

open_episode() {
	anime_id=$1
	episode=$2
	ddir="$3"

	if [ $half_ep -eq 1 ]; then
		temp_ep=$episode
		episode=$episode"-5"
	fi

	logger "Getting data for episode $episode"

	# Don't update watch history if downloading episode
	if [ "$is_download" -eq 0 ]; then
		insert_history "$anime_id" "$episode" &
	fi

	dpage_link=$(get_dpage_link "$anime_id" "$episode")
	video_url=$(get_video_quality "$dpage_link")
	logger "Download link: $video_url"
	logger "Video url: $video_url"

	if [ $half_ep -eq 1 ]; then
		episode=$temp_ep
		half_ep=0
	fi

	if [ "$is_download" -eq 0 ]; then
		kill "$PID" > /dev/null 2>&1
		nohup "$player_fn" --http-header-fields="Referer:$dpage_link" "$video_url" > /dev/null 2>&1 &
		PID=$!
		if command -v "notify-send" > /dev/null; then
			notify-send -i "$ANIWRAPPER_ICON_PATH" "Playing $anime_id - Episode $episode"
		else
			printf "${c_green}\nVideo playing"
		fi
	else
		logger "Downloading episode $episode ..."
		dl_dir="${ddir// /}/$anime_id"
		# add 0 padding to the episode name
		episode=$(printf "%03d" "$episode")
		{
			mkdir -p "$dl_dir" || die "Could not create directory"
			if command -v "notify-send" > /dev/null; then
				aria2c -x 16 -s 16 --referer="$dpage_link" "$video_url" --dir="$dl_dir" -o "$episode.mp4" --download-result=hide &&
					notify-send -i "$ANIWRAPPER_ICON_PATH" "Download complete for ${anime_id//-/ } - Episode: $episode" ||
					notify-send -i "$MAISAN_ICON_PATH" "Download failed for ${anime_id//-/ } - Episode: $episode. Please retry or check your internet connection"
			else
				aria2c -x 16 -s 16 --referer="$dpage_link" "$video_url" --dir="$dl_dir" -o "$episode.mp4" --download-result=hide &&
					printf "${c_green}Downloaded complete for %s - Episode: %s${c_reset}\n" "${anime_id//-/ }" "$episode" ||
					printf "${c_red}Download failed for %s - Episode: %s, please retry or check your internet connection${c_reset}\n" "${anime_id//-/ }" "$episode"

			fi
		}
	fi
}

stream() {
	logger "Running stream()"
	logger "args: $*"
	get_search_query "$*"
	searched=0
	if [ $# -le 1 ]; then
		# check if anime has been searched before
		anime_id="${query// /}"
		[ -z "$anime_id" ] && die "No anime selected or queried"
		logger "Checking if anime: $anime_id has been searched before..."
		check_db "$anime_id" "search"
		searched="$?"
		logger "Searched before: $searched"
	fi
	if [ "$searched" -eq 0 ]; then
		search_results=$(search_anime "$query")
		[ -z "$search_results" ] && die "No search results found"
		logger "SEARCH RESULTS: $search_results"
		if ! anime_selection "$search_results"; then
			die "No anime selection found"
		fi
	else
		# if the query is a previous search
		# skip search_anime function and assign $query
		anime_id="${query// /}"
		selection_id="$anime_id"
		insert_history "$anime_id" "search" &
		read -r last_ep_number <<< "$(search_eps "$selection_id")"
	fi
	episode_selection
}

# to clear the colors when exited using SIGINT
trap "printf '$c_reset'" INT HUP

# option parsing
scrape=query
quality=best
is_rofi=1
is_download=0
download_dir="."
half_ep=0
while getopts 'hd:Hsvq:c-:f:t:T:CQ:D:' OPT; do
	case "$OPT" in
		h)
			help_text
			exit 0
			;;
		d)
			is_download=1
			download_dir="$OPTARG"
			logger "DOWNLOAD DIR: $download_dir"
			;;
		H)
			scrape=history
			;;
		s)
			scrape=sync
			;;
		v)
			VERBOSE=1
			;;
		q)
			quality="$OPTARG"
			logger "passed in quality: $quality"
			;;
		c)
			is_rofi=0
			;;
		-)
			case $OPTARG in
				dub)
					dub_prefix="-dub"
					;;
				*)
					help_text
					exit 1
					;;
			esac
			;;
		f)
			scrape="file"
			play_dir="$OPTARG"
			[ "$play_dir" != "/" ] && play_dir="$(sed -E 's/\/$//' <<< "$play_dir")" # remove trailing slash... unless searching / for some reason
			;;
		t)
			theme="$OPTARG"
			case "$theme" in
				aniwrapper)
					ROFI_THEME=aniwrapper.rasi
					;;
				default)
					ROFI_THEME=aniwrapper.rasi
					;;
				dracula)
					ROFI_THEME=aniwrapper-dracula.rasi
					;;
				doomone | doom-one)
					ROFI_THEME=aniwrapper-doomone.rasi
					;;
				fancy)
					ROFI_THEME=aniwrapper-fancy.rasi
					;;
				flamingo)
					ROFI_THEME=aniwrapper-flamingo.rasi
					;;
				material)
					ROFI_THEME=aniwrapper-material.rasi
					;;
				nord)
					ROFI_THEME=aniwrapper-nord.rasi
					;;
				onedark)
					ROFI_THEME=aniwrapper-onedark.rasi
					;;
				*)
					die "$theme not a valid theme file.  Themes: [$THEMES]"
					;;
			esac
			logger "Setting theme for ani-cli -> $ROFI_THEME"
			ROFI_CFG="$CFG_DIR/themes/$ROFI_THEME"
			logger "ROFI_CFG: $ROFI_CFG"
			;;
		T)
			ROFI_CFG="$OPTARG"
			[ ! -f "$ROFI_CFG" ] && die "$ROFI_CFG does not exist"
			logger "CUSTOM ROFI_CFG: $ROFI_CFG"
			;;
		C)
			logger "Connecting to history database -> $CFG_DIR/history.sqlite3"
			sqlite3 "$CFG_DIR/history.sqlite3"
			exit $?
			;;
		Q)
			query="$OPTARG"
			logger "DATABASE QUERY: $query"
			sqlite3 -line "$CFG_DIR/history.sqlite3" "$query"
			exit $?
			;;
		D)
			DPI="$OPTARG"
			;;
		*)
			printf "%s\n" "Invalid option"
			exit 1
			;;
	esac
done
shift $((OPTIND - 1))

dep_ch "$player_fn" "curl" "sed" "grep" "sqlite3" "rofi" "git" "aria2c" "jq"

########
# main #
########

case $scrape in
	query)
		stream "$*"
		;;
	history)
		stmt="SELECT DISTINCT anime_name FROM watch_history ORDER BY watch_date DESC"
		search_results=$(printf "%s\n" "$stmt" | sqlite3 -noheader "$HISTORY_DB")
		[ -z "$search_results" ] && die "History is empty"
		if ! anime_selection "${search_results[@]}"; then
			die "No anime selection found"
		fi
		logger "SELECTION: $selection_id"

		stmt="SELECT episode_number \
			FROM watch_history \
			WHERE anime_name = '$selection_id' \
			ORDER BY watch_date DESC \
			LIMIT 1"
		ep_choice_start=$(run_stmt "$stmt")
		logger "Most recently watched episode: $ep_choice_start"
		;;
	sync)
		printf "%s" "Enter username for remote user: "
		read -r username
		printf "%s" "Enter host for remote user: "
		read -r host

		connection_str="$username@$host"
		printf "%s" "Enter port to connect to remote host with or leave blank for default (22): "
		read -r port
		if [[ "${port/ //}" == "" ]]; then
			PORT=22
		else
			PORT="$port"
		fi

		printf "%s" "Enter path to private key (leave blank if unsure or not needed): "
		read -r key_path

		printf "%s\n" "Syncing database with: $connection_str on port $PORT"
		temp_db="/tmp/aniwrapper_tmp_history.sqlite3"

		if [[ -z "$key_path" ]]; then
			scp -P "$PORT" "$connection_str:$HISTORY_DB" "$temp_db"
		else
			scp -P "$PORT" -i "$key_path" "$connection_str:$HISTORY_DB" "$temp_db"
		fi
		if [[ "$?" -ne 0 ]]; then
			die "Error getting database file from remote host"
		fi
		sync_search_history && sync_watch_history
		exit $?
		;;
	file)
		logger "STARTING DIR: $play_dir"
		[ ! -d "$play_dir" ] && die "$play_dir does not exist"
		insert_history "directory" "$play_dir" &
		video_path=$(find_media "$play_dir")
		retcode="$?"
		if [ "$retcode" -ne 0 ]; then
			die "QUITTING"
		elif [ -z "$video_path" ]; then
			die "Something went wrong getting path... path is empty"
		fi
		logger "VIDEO PATH: $video_path"
		play_file "$video_path"
		exit $?
		;;
esac

check_input

# plays selected episode(s)
for ep in $episodes; do
	open_episode "$selection_id" "$ep" "$download_dir"
done

if [[ "$is_download" -eq 1 ]]; then
	logger "Finished downloading episodes: $episodes for $selection_id... exiting"
	exit 0
fi

episode=${ep_choice_end:-$ep_choice_start}

choice=''
while :; do
	printf "\n${c_green}Currently playing %s episode ${c_cyan}%d/%d\n" "$selection_id" $episode $last_ep_number
	if [ "$episode" -ne "$last_ep_number" ]; then
		printf "$c_blue[${c_cyan}%s$c_blue] $c_yellow%s$c_reset\n" "n" "next episode"
	fi
	if [ "$episode" -ne "1" ]; then
		printf "$c_blue[${c_cyan}%s$c_blue] $c_magenta%s$c_reset\n" "p" "previous episode"
	fi
	if [ "$last_ep_number" -ne "1" ]; then
		printf "$c_blue[${c_cyan}%s$c_blue] $c_yellow%s$c_reset\n" "s" "select episode"
	fi
	printf "$c_blue[${c_cyan}%s$c_blue] $c_magenta%s$c_reset\n" "r" "replay current episode"
	printf "$c_blue[${c_cyan}%s$c_blue] $c_yellow%s$c_reset\n" "a" "search for another anime"
	# printf "$c_blue[${c_cyan}%s$c_blue] $c_magenta%s$c_reset\n" "h" "search history"
	printf "$c_blue[${c_cyan}%s$c_blue] $c_red%s$c_reset\n" "q" "exit"
	printf "${c_blue}Enter choice:${c_green} "
	read -r choice

	printf "$c_reset"
	case $choice in
		n)
			episode=$((episode + 1))
			;;
		p)
			episode=$((episode - 1))
			;;

		s)
			printf "${c_blue}Choose episode $c_cyan[1-%d]$c_reset:$c_green " "$last_ep_number"
			read -r episode
			if [ "$(echo "$episode" | cut -c1-1)" = "h" ]; then
				half_ep=1
				episode=$(echo "$episode" | cut -c2-)
			fi
			printf "$c_reset"
			[ "$episode" -eq "$episode" ] 2> /dev/null || die "Invalid number entered"
			;;

		r)
			episode=$((episode))
			;;
		a)
			stream
			episode=$ep_choice_start
			logger "NEW EPISODE: $selection_id - $episode"
			;;

		q)
			break
			;;

		*)
			die "invalid choice"
			;;
	esac
	open_episode "$selection_id" "$episode" "$download_dir"
done
